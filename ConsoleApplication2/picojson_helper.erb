require 'erb'

# ユーザ定義型をpicojson::objectから変換，picojson::objectに変換するためのメンバ関数を定義する
# マクロを生成するrubyスクリプト
# usage
#   ruby json_helper.erb                     # 標準出力に出力される
#   ruby json_helper.erb > json_helper.hpp
# 
# ...
# #include "picojson.h"
# #include "json_helper.hpp"
#
# struct sample {
#    int a, b, c, d;
#    std::string f;
# public:
#    PICOJSON_DEFINE(sample, a, b, c, d, f) // 定義
# };
#
# int main()
# {
#     // serialize to picojson::object
#     sample s;
#     picojson::object root;
#     picojson::pack(root, s);
#
#     // deserialize from picojson::object
#     sample s2;
#     picojson::unpack(root, s2);
#     std::cout << s2 << std::endl;
# }
#
# 現状JSON_DEFINE()に渡すことのできる型はbool, double, std::string, picojson::null, 
# picojson::array(=std::vector<picojson::value>), picojson::object(=std::map<picojson::value>)のみ

MAX_ITER = 10  # 可変長引数の最大次数

# 指定個数の引数
def args(name, n)
   (1 .. n).map{ |i| name + i.to_s() }.join(",")
end 

contents =<<EOS
#pragma once

// Calculate the count of arguments.
#define PICOJSON_NUM_VA_ARGS_I(<%= args('_', MAX_ITER) %>,N,...) N
#define PICOJSON_NUM_VA_ARGS_I_(tuple) PICOJSON_NUM_VA_ARGS_I tuple
#define PICOJSON_NUM_VA_ARGS(...) PICOJSON_NUM_VA_ARGS_I_(\
   (__VA_ARGS__, <%= [*1 .. MAX_ITER].reverse.map{ |i| i.to_s() }.join(",") %>))

// definition of pack/unpack method
<% (1 .. MAX_ITER).each do |n| %>
   <% if n == 1 then %>
      // pack
      #define PICOJSON_DEFINE_PACK_1(clsname, a1)    PICOJSON_DEFINE_PACK_ITEM  (clsname, a1)
      // unpack
      #define PICOJSON_DEFINE_UNPACK_1(clsname, a1)  PICOJSON_DEFINE_UNPACK_ITEM(clsname, a1)
   <% else %>
      // pack
      #define PICOJSON_DEFINE_PACK_<%= n %>(clsname, <%= args('a', n) %>) \\
         PICOJSON_DEFINE_PACK_<%= n %>_I_((clsname,  <%= args('a', n) %>))

      #define PICOJSON_DEFINE_PACK_<%= n %>_I_(tuple) PICOJSON_DEFINE_PACK_<%= n %>_I tuple 
      
      #define PICOJSON_DEFINE_PACK_<%= n %>_I(clsname, <%= args('a', n) %>) \\
         PICOJSON_DEFINE_PACK_<%= n - 1 %>(clsname, <%= args('a', n-1) %>) \\
         PICOJSON_DEFINE_PACK_ITEM(clsname, a<%= n %>)
      
      // unpack
      #define PICOJSON_DEFINE_UNPACK_<%= n %>(clsname, <%= args('a', n) %>) \\
         PICOJSON_DEFINE_UNPACK_<%= n %>_I_((clsname,  <%= args('a', n) %>))
      
      #define PICOJSON_DEFINE_UNPACK_<%= n %>_I_(tuple) PICOJSON_DEFINE_UNPACK_<%= n %>_I tuple 
      
      #define PICOJSON_DEFINE_UNPACK_<%= n %>_I(clsname, <%= args('a', n) %>) \\
         PICOJSON_DEFINE_UNPACK_<%= n - 1 %>(clsname, <%= args('a', n) %>) \\
         PICOJSON_DEFINE_UNPACK_ITEM(clsname, a<%= n %>)
   <% end %>
<% end %>

#define PICOJSON_DEFINE_PACK_ITEM(clsname, a) \\
   root.insert( std::make_pair( std::string(#a), picojson::value(a) ) );
#define PICOJSON_DEFINE_UNPACK_ITEM(clsname, a) \\
   a = root.at(#a).get < decltype(a) > ();
   
#define PICOJSON_DEFINE_I(clsname, N, ...) \\
   void picojson_pack(picojson::object& root) const { \\
      PICOJSON_DEFINE_PACK_##N(clsname, __VA_ARGS__) \\
   }\\
   void picojson_unpack(picojson::object const& root) { \\
      PICOJSON_DEFINE_UNPACK_##N(clsname, __VA_ARGS__) \\
   }
#define PICOJSON_DEFINE_I_(tuple) PICOJSON_DEFINE_I tuple 
#define PICOJSON_DEFINE_I__(clsname, N, ...) PICOJSON_DEFINE_I_((clsname, N, __VA_ARGS__)) 
#define PICOJSON_DEFINE(clsname, ...) \\
   PICOJSON_DEFINE_I__(clsname, PICOJSON_NUM_VA_ARGS(__VA_ARGS__), __VA_ARGS__)


namespace picojson {

template <typename Type>
void pack(object& root, Type const& val) {
   val.picojson_pack(root);
}
template <typename Type>
void unpack(object const& root, Type& val) {
   val.picojson_unpack(root);
}
}//namespace picojson;

EOS

erb = ERB.new(contents)
puts erb.result(binding)
