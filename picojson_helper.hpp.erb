/* 
 * Copyright (c) 2015 Yusuke Sasaki
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#pragma once

#include <sstream>
#include <type_traits>
#include <vector>

#if defined(_MSC_VER)
# pragma warning(disable:4002)
# pragma warning(disable:4003)
#endif

<%# 可変長引数の最大次数 %>
<% MAX_ITER = 31 %>
<%# 指定個数の引数 %>
<%
def args(name, n)
   (1 .. n).map{ |i| name + i.to_s() }.join(",")
end 
%>

// Calculate the count of arguments.
#define PICOJSON_NUM_VA_ARGS_I(<%= args('_', MAX_ITER) %>,N,...) N
#define PICOJSON_NUM_VA_ARGS_I_(tuple) PICOJSON_NUM_VA_ARGS_I tuple
#define PICOJSON_NUM_VA_ARGS(...) PICOJSON_NUM_VA_ARGS_I_(\
   (__VA_ARGS__, <%= [*1 .. MAX_ITER].reverse.map{ |i| i.to_s() }.join(",") %>))

<%# definition of pack/unpack method %>
<% (1 .. MAX_ITER).each do |n| %>
   <% if n == 1 then %>
      <%# pack %>
      #define PICOJSON_DEFINE_PACK_1(obj, a1)    PICOJSON_DEFINE_PACK_ITEM  (obj, a1)
      <%# unpack %>
      #define PICOJSON_DEFINE_UNPACK_1(obj, a1)  PICOJSON_DEFINE_UNPACK_ITEM(obj, a1)
   <% else %>
      <%# pack %>
      #define PICOJSON_DEFINE_PACK_<%=n%>(obj, <%=args('a',n)%>) \
          PICOJSON_DEFINE_PACK_<%=n%>_I_((obj, <%=args('a',n)%>))
      #define PICOJSON_DEFINE_PACK_<%=n%>_I_(tuple) \
          PICOJSON_DEFINE_PACK_<%=n%>_I tuple 
      #define PICOJSON_DEFINE_PACK_<%=n%>_I(obj, <%=args('a',n)%>) \
          PICOJSON_DEFINE_PACK_<%=n-1%>  (obj, <%=args('a',n-1)%>) \
          PICOJSON_DEFINE_PACK_ITEM          (obj, a<%=n%>)
      <%# unpack %>
      #define PICOJSON_DEFINE_UNPACK_<%=n%>(obj, <%=args('a', n) %>) \
          PICOJSON_DEFINE_UNPACK_<%=n%>_I_((obj, <%=args('a',n) %>))
      #define PICOJSON_DEFINE_UNPACK_<%=n%>_I_(tuple) \
          PICOJSON_DEFINE_UNPACK_<%=n%>_I tuple 
      #define PICOJSON_DEFINE_UNPACK_<%=n%>_I(obj, <%=args('a',n)%>) \
          PICOJSON_DEFINE_UNPACK_<%=n-1%>  (obj, <%=args('a',n-1)%>) \
          PICOJSON_DEFINE_UNPACK_ITEM          (obj, a<%=n%>)
   <% end %>
<% end %>
 
#define PICOJSON_DEFINE_PACK_ITEM(obj, a) \
   picojson::to_value(v, a); \
   obj.insert( std::make_pair( std::string(#a), v ) );
#define PICOJSON_DEFINE_UNPACK_ITEM(obj, a) \
   picojson::from_value(a, obj.at(#a));
 
#define PICOJSON_DEFINE_I(N, ...) \
   void picojson_pack(picojson::value& root) const { \
      picojson::object obj; \
      picojson::value v; \
      PICOJSON_DEFINE_PACK_##N(obj, __VA_ARGS__) \
      root.swap(picojson::value(obj)); \
   } \
   void picojson_unpack(picojson::value const& root) { \
      picojson::object const& obj = root.get<picojson::object>(); \
      PICOJSON_DEFINE_UNPACK_##N(obj, __VA_ARGS__) \
   }

#define PICOJSON_DEFINE_I_(tuple) PICOJSON_DEFINE_I tuple 
#define PICOJSON_DEFINE_I__(N, ...) PICOJSON_DEFINE_I_((N, __VA_ARGS__)) 
#define PICOJSON_DEFINE(...) \
   PICOJSON_DEFINE_I__(PICOJSON_NUM_VA_ARGS(__VA_ARGS__), __VA_ARGS__)
   

namespace picojson {

namespace detail {

<%# OR %>
template <bool A0<% 1.upto(MAX_ITER){|i| %>, bool A<%=i%> = false<%}%>>
struct or {
    static const bool value = A0<% 1.upto(MAX_ITER) {|i|%>|| A<%=i%><%}%>;
};

<%# AND %>
template <bool A0<% 1.upto(MAX_ITER){|i| %>, bool A<%=i%> = true <%}%>>
struct and {
    static const bool value = A0<% 1.upto(MAX_ITER) {|i|%>&& A<%=i%><%}%>;
};

<%# NOT %>
template<bool A>
struct not {
   static const bool value = !A;
};

template <typename T>
struct is_picojson_type : or< 
  std::is_same<T, null>::value,
  std::is_same<T, bool>::value,
  std::is_same<T, double>::value,
  std::is_same<T, std::string>::value,
  std::is_same<T, array>::value,
  std::is_same<T, object>::value,
  std::is_same<T, value>::value
> {};

template <typename T>
struct is_stl_container : std::false_type {};
template <typename T>
struct is_stl_container<std::vector<T>> : std::true_type {};

template<typename T>
class has_member_pack
{
    template <typename U, void(U::*)(value&) const> struct Check;
    template <typename U> static char func(Check<U, &U::picojson_pack>*);
    template <typename U> static int func(...);
public:
    typedef has_member_pack type;
    static const bool value = (sizeof(func<T>(0)) == sizeof(char));
};

template<typename T>
class has_member_unpack
{
    template <typename U, void(U::*)(value const&)> struct Check;
    template <typename U> static char func(Check<U, &U::picojson_unpack>*);
    template <typename U> static int func(...);
public:
    typedef has_member_unpack type;
    static const bool value = (sizeof(func<T>(0)) == sizeof(char));
};

template <typename T>
struct is_arithmetic : and<
   !is_picojson_type<T>::value,
   std::is_arithmetic<T>::value
> {};

template <typename T>
struct is_user_defined : and<
   !is_picojson_type<T>::value,
   !std::is_arithmetic<T>::value,
   !is_stl_container<T>::value
> {};

}//namespace detail;


template <typename T>
typename std::enable_if<detail::is_picojson_type<T>::value>::type
  to_value(value& v, T const& val)
{
    v = value(val);
}

template <typename T>
typename std::enable_if<detail::is_arithmetic<T>::value>::type
  to_value(value& v, T const& val)
{
    v = value((double)val);
}

template <typename T>
typename std::enable_if<!std::is_same<T, value>::value>::type
  to_value(value& v, std::vector<T> const& val)
{
    // std::vector<T> (T is not picojson::value)
    array arr;
    std::transform(std::begin(val), std::end(val), std::back_inserter(arr),
                   [](T const& val){ picojson::value v; to_value(v, val); return v; });
    v = value(arr);
}

template <typename T>
typename std::enable_if<
    detail::and<
        detail::is_user_defined<T>::value,
        detail::has_member_pack<T>::value
    >::value
>::type
  to_value(value& v, T const& val)
{
    // user defined type (with T::pack(value&) const)
    value root;
    val.picojson_pack(root);
    v = root;
}

template <typename T>
typename std::enable_if<
    detail::and<
        detail::is_user_defined<T>::value,
       !detail::has_member_pack<T>::value
    >::value
>::type
  to_value(value& v, T const& val)
{
    // user defined type (without T::pack(value&) const)
    std::ostringstream sstr;
    sstr << val;
    v = value(sstr.str());
}


template <typename T>
typename std::enable_if<detail::is_picojson_type<T>::value>::type
  from_value(T& val, value const& v)
{
    val = v.get<T>();
}

template <typename T>
typename std::enable_if<detail::is_arithmetic<T>::value>::type
  from_value(T& val, value const& v)
{
    val = static_cast<T>(v.get<double>());
}

template <typename T>
typename std::enable_if<!std::is_same<T, value>::value>::type
  from_value(std::vector<T>& val, value const& v)
{
    // std::vector<T> (T is not picojson::value)
    array arr = v.get<array>();
    val.resize(arr.size());
    std::transform(std::begin(arr), std::end(arr), std::begin(val), 
            [](value const& v_)->T{ T r; picojson::from_value(r, v_); return r; });
}

template <typename T>
typename std::enable_if<
    detail::and<
        detail::is_user_defined<T>::value,
        detail::has_member_unpack<T>::value
    >::value
>::type
  from_value(T& val, value const& v)
{
    // user defined type (with T::pack(value&) const)
    val.picojson_unpack(v);
}

template <typename T>
typename std::enable_if<
    detail::and<
         detail::is_user_defined<T>::value,
        !detail::has_member_unpack<T>::value
    >::value
>::type
  from_value(T& val, value const& v)
{
    // user defined type (without T::pack(value&) const)
    std::string str = v.get<std::string>();
    std::istringstream sstr(str);
    sstr >> val;
}

}// namespace picojson;

