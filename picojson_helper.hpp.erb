require 'erb'

# ユーザ定義型をpicojson::objectから変換，picojson::objectに変換するためのメンバ関数を定義する
# マクロを生成するrubyスクリプト
# usage
#   ruby json_helper.erb                     # 標準出力に出力される
#   ruby json_helper.erb > json_helper.hpp
# 
# ...
# #include "picojson.h"
# #include "json_helper.hpp"
#
# struct sample {
#    int a, b, c, d;
#    std::string f;
# public:
#    PICOJSON_DEFINE(sample, a, b, c, d, f) // 定義
# };
#
# int main()
# {
#     // serialize to picojson::object
#     sample s;
#     picojson::object root;
#     picojson::pack(root, s);
#
#     // deserialize from picojson::object
#     sample s2;
#     picojson::unpack(root, s2);
#     std::cout << s2 << std::endl;
# }
#
# 現状JSON_DEFINE()に渡すことのできる型はbool, double, std::string, picojson::null, 
# picojson::array(=std::vector<picojson::value>), picojson::object(=std::map<picojson::value>)のみ

MAX_ITER = 31  # 可変長引数の最大次数

# 指定個数の引数
def args(name, n)
   (1 .. n).map{ |i| name + i.to_s() }.join(",")
end 

contents =<<EOS
#pragma once

// Calculate the count of arguments.
#define PICOJSON_NUM_VA_ARGS_I(<%= args('_', MAX_ITER) %>,N,...) N
#define PICOJSON_NUM_VA_ARGS_I_(tuple) PICOJSON_NUM_VA_ARGS_I tuple
#define PICOJSON_NUM_VA_ARGS(...) PICOJSON_NUM_VA_ARGS_I_(\
   (__VA_ARGS__, <%= [*1 .. MAX_ITER].reverse.map{ |i| i.to_s() }.join(",") %>))

<%# definition of pack/unpack method %>
<% (1 .. MAX_ITER).each do |n| %>
   <% if n == 1 then %>
      <%# pack %>
      #define PICOJSON_DEFINE_PACK_1(obj, a1)    PICOJSON_DEFINE_PACK_ITEM  (obj, a1)
      <%# unpack %>
      #define PICOJSON_DEFINE_UNPACK_1(obj, a1)  PICOJSON_DEFINE_UNPACK_ITEM(obj, a1)
   <% else %>
      <%# pack %>
      #define PICOJSON_DEFINE_PACK_<%= n %>(obj, <%= args('a', n) %>)       \\
          PICOJSON_DEFINE_PACK_<%= n %>_I_((obj, <%= args('a', n) %>))
      #define PICOJSON_DEFINE_PACK_<%= n %>_I_(tuple)                        \\
          PICOJSON_DEFINE_PACK_<%= n %>_I tuple 
      #define PICOJSON_DEFINE_PACK_<%= n %>_I(obj, <%= args('a', n) %>)     \\
          PICOJSON_DEFINE_PACK_<%= n - 1 %>  (obj, <%= args('a', n - 1) %>) \\
          PICOJSON_DEFINE_PACK_ITEM          (obj, a<%= n %>)
      <%# unpack %>
      #define PICOJSON_DEFINE_UNPACK_<%= n %>(obj, <%= args('a', n) %>)     \\
          PICOJSON_DEFINE_UNPACK_<%= n %>_I_((obj, <%= args('a', n) %>))
      #define PICOJSON_DEFINE_UNPACK_<%= n %>_I_(tuple)                       \\
          PICOJSON_DEFINE_UNPACK_<%= n %>_I tuple 
      #define PICOJSON_DEFINE_UNPACK_<%= n %>_I(obj, <%= args('a', n) %>)     \\
          PICOJSON_DEFINE_UNPACK_<%= n - 1 %>  (obj, <%= args('a', n - 1) %>) \\
          PICOJSON_DEFINE_UNPACK_ITEM          (obj, a<%= n %>)
   <% end %>
<% end %>
 
#define PICOJSON_DEFINE_PACK_ITEM(obj, a) \\
   obj.insert( std::make_pair( std::string(#a), picojson::to_value(a) ) );
#define PICOJSON_DEFINE_UNPACK_ITEM(obj, a) \\
   a <<= obj.at(#a);
 
#define PICOJSON_DEFINE_I(N, ...)                                 \\
   void picojson_pack(picojson::value& root) const {              \\
      picojson::object obj;                                       \\
      PICOJSON_DEFINE_PACK_##N(obj, __VA_ARGS__)                  \\
      root.swap(picojson::value(obj));                            \\
   }                                                              \\
   void picojson_unpack(picojson::value const& root) {            \\
      picojson::object const& obj = root.get<picojson::object>(); \\
      PICOJSON_DEFINE_UNPACK_##N(obj, __VA_ARGS__)                \\
   }

#define PICOJSON_DEFINE_I_(tuple) PICOJSON_DEFINE_I tuple 
#define PICOJSON_DEFINE_I__(N, ...) PICOJSON_DEFINE_I_((N, __VA_ARGS__)) 
#define PICOJSON_DEFINE(...) \\
   PICOJSON_DEFINE_I__(PICOJSON_NUM_VA_ARGS(__VA_ARGS__), __VA_ARGS__)
   

namespace picojson {

template <typename Type>
void pack(value& root, Type const& val) {
   val.picojson_pack(root);
}
template <typename Type>
void unpack(value const& root, Type& val) {
   val.picojson_unpack(root);
}

namespace detail {
<%# OR %>
template<bool A1, <%= (2..MAX_ITER).map{ |i| 'bool A' + i.to_s() + ' = false'}.join(',') %> >
struct or {
   static const bool value = <%= (1..MAX_ITER).map{|i| 'A'+i.to_s()}.join('||') %>;
};
<%# AND %>
template<bool A1, <%= (2..MAX_ITER).map{ |i| 'bool A' + i.to_s() + ' = true'}.join(',') %> >
struct and {
   static const bool value = <%= (1..MAX_ITER).map{|i| 'A'+i.to_s()}.join('&&') %>;
};
<%# NOT %>
template< bool A >
struct not {
   static const bool value = !A;
};

template <typename T>
struct is_picojson_type {
    static const bool value = or< 
        std::is_same<T, picojson::null>::value,
        std::is_same<T, bool>::value,
        std::is_same<T, double>::value,
        std::is_same<T, std::string>::value,
        std::is_same<T, picojson::array>::value,
        std::is_same<T, picojson::object>::value
    >::value;
};

template <typename T>
struct is_stl_container : std::false_type {};
template <typename T>
struct is_stl_container<std::vector<T>> : std::true_type {};

template<typename T>
class has_member_pack
{
    template <typename U, void(U::*)(value&) const> struct Check;
    template <typename U> static char func(Check<U, &U::picojson_pack>*);
    template <typename U> static int func(...);
public:
    typedef has_member_pack type;
    static const bool value = (sizeof(func<T>(0)) == sizeof(char));
};

template<typename T>
class has_member_unpack
{
    template <typename U, void(U::*)(value const&)> struct Check;
    template <typename U> static char func(Check<U, &U::picojson_unpack>*);
    template <typename U> static int func(...);
public:
    typedef has_member_unpack type;
    static const bool value = (sizeof(func<T>(0)) == sizeof(char));
};

}//namespace detail;

}//namespace picojson;

EOS

erb = ERB.new(contents)
puts erb.result(binding)
